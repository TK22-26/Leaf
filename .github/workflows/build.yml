name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Generate Version
      id: version
      shell: pwsh
      run: |
        $now = Get-Date
        $midnight = $now.Date
        $minutesSinceMidnight = [int]($now - $midnight).TotalMinutes
        $version = "$($now.ToString('yyyy.MM.dd')).$minutesSinceMidnight"
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "Generated version: $version"

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '10.0.x'

    - name: Restore dependencies
      run: dotnet restore src/Leaf/Leaf.csproj

    - name: Build
      run: dotnet build src/Leaf/Leaf.csproj --configuration Release --no-restore /p:Version=${{ steps.version.outputs.VERSION }}

    - name: Publish
      run: dotnet publish src/Leaf/Leaf.csproj --configuration Release --no-build --output ./publish /p:Version=${{ steps.version.outputs.VERSION }}

    - name: Publish (MSIX)
      run: dotnet publish src/Leaf/Leaf.csproj --configuration Release -r win-x64 --self-contained true --output ./publish-msix /p:Version=${{ steps.version.outputs.VERSION }}

    - name: Install WiX Toolset
      shell: pwsh
      run: |
        dotnet tool install --global wix
        echo "$env:USERPROFILE\\.dotnet\\tools" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Create MSIX Package
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"

        function Get-WindowsKitTool([string]$toolName) {
          $roots = @(
            (Join-Path ${env:ProgramFiles(x86)} "Windows Kits\\10\\bin"),
            (Join-Path $env:ProgramFiles "Windows Kits\\10\\bin")
          ) | Where-Object { $_ -and (Test-Path $_) }

          foreach ($root in $roots) {
            $versionDirs = Get-ChildItem $root -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.Name -match '^\d+\.' } |
              Sort-Object { [version]$_.Name } -Descending

            foreach ($dir in $versionDirs) {
              $candidate = Join-Path $dir.FullName ("x64\\" + $toolName)
              if (Test-Path $candidate) { return $candidate }
            }

            $fallback = Join-Path $root ("x64\\" + $toolName)
            if (Test-Path $fallback) { return $fallback }
          }

          return $null
        }

        $version = "${{ steps.version.outputs.VERSION }}"
        $msixVersion = ($version.Split('.') | ForEach-Object { [int]$_ }) -join '.'
        $identityName = if ($env:MSIX_IDENTITY_NAME) { $env:MSIX_IDENTITY_NAME } else { "Leaf" }
        $publisher = if ($env:MSIX_PUBLISHER) { $env:MSIX_PUBLISHER } else { "CN=Leaf" }
        $displayName = if ($env:MSIX_DISPLAY_NAME) { $env:MSIX_DISPLAY_NAME } else { "Leaf" }
        $publisherDisplayName = if ($env:MSIX_PUBLISHER_DISPLAY_NAME) { $env:MSIX_PUBLISHER_DISPLAY_NAME } else { $displayName }

        $msixStaging = Join-Path $pwd "msix"
        if (Test-Path $msixStaging) { Remove-Item $msixStaging -Recurse -Force }
        New-Item -ItemType Directory -Path $msixStaging -Force | Out-Null

        Copy-Item ./publish-msix/* $msixStaging -Recurse -Force
        New-Item -ItemType Directory -Path "$msixStaging\\Assets" -Force | Out-Null
        Copy-Item ./src/Leaf/Assets/Leaf.png "$msixStaging\\Assets\\Leaf.png" -Force
        Copy-Item ./packaging/msix/AppxManifest.xml "$msixStaging\\AppxManifest.xml" -Force

        $manifestPath = "$msixStaging\\AppxManifest.xml"
        $manifest = Get-Content $manifestPath -Raw
        $manifest = $manifest.Replace("{{VERSION}}", $msixVersion)
        $manifest = $manifest.Replace("{{IDENTITY_NAME}}", $identityName)
        $manifest = $manifest.Replace("{{PUBLISHER}}", $publisher)
        $manifest = $manifest.Replace("{{DISPLAY_NAME}}", $displayName)
        $manifest = $manifest.Replace("{{PUBLISHER_DISPLAY_NAME}}", $publisherDisplayName)
        Set-Content -Path $manifestPath -Value $manifest -Encoding UTF8

        $msixPath = Join-Path $pwd "Leaf.msix"
        if (Test-Path $msixPath) { Remove-Item $msixPath -Force }
        $makeAppx = Get-WindowsKitTool "makeappx.exe"
        if (-not $makeAppx) { throw "makeappx.exe not found. Install Windows 10/11 SDK on the runner." }
        & $makeAppx pack /d $msixStaging /p $msixPath /o

    - name: Sign MSIX Package
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"

        function Get-WindowsKitTool([string]$toolName) {
          $roots = @(
            (Join-Path ${env:ProgramFiles(x86)} "Windows Kits\\10\\bin"),
            (Join-Path $env:ProgramFiles "Windows Kits\\10\\bin")
          ) | Where-Object { $_ -and (Test-Path $_) }

          foreach ($root in $roots) {
            $versionDirs = Get-ChildItem $root -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.Name -match '^\d+\.' } |
              Sort-Object { [version]$_.Name } -Descending

            foreach ($dir in $versionDirs) {
              $candidate = Join-Path $dir.FullName ("x64\\" + $toolName)
              if (Test-Path $candidate) { return $candidate }
            }

            $fallback = Join-Path $root ("x64\\" + $toolName)
            if (Test-Path $fallback) { return $fallback }
          }

          return $null
        }

        $msixPath = Join-Path $pwd "Leaf.msix"
        if (-not (Test-Path $msixPath)) {
          Write-Error "MSIX not found at $msixPath"
          exit 1
        }

        $signTool = Get-WindowsKitTool "signtool.exe"
        if (-not $signTool) { throw "signtool.exe not found. Install Windows 10/11 SDK on the runner." }

        if ($env:MSIX_PFX_BASE64 -and $env:MSIX_PFX_PASSWORD) {
          $pfxPath = Join-Path $pwd "Leaf.pfx"
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:MSIX_PFX_BASE64))
          & $signTool sign /fd SHA256 /f $pfxPath /p $env:MSIX_PFX_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $msixPath
        }
        else {
          $cert = New-SelfSignedCertificate -Type CodeSigningCert -Subject "CN=Leaf" -CertStoreLocation "Cert:\\CurrentUser\\My"
          $tempPassword = "Leaf-Temporary-Password-2026!"
          $securePassword = ConvertTo-SecureString -String $tempPassword -AsPlainText -Force
          $pfxPath = Join-Path $pwd "Leaf-Test.pfx"
          $cerPath = Join-Path $pwd "Leaf-Test.cer"
          Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $securePassword | Out-Null
          Export-Certificate -Cert $cert -FilePath $cerPath | Out-Null
          & $signTool sign /fd SHA256 /f $pfxPath /p $tempPassword /tr http://timestamp.digicert.com /td SHA256 $msixPath
        }

    - name: Create MSI Package
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"

        $version = "${{ steps.version.outputs.VERSION }}"
        $parts = $version.Split('.')
        $year = [int]$parts[0]
        $month = [int]$parts[1]
        $day = [int]$parts[2]
        $minutes = [int]$parts[3]
        $major = $year - 2000
        $minor = $month
        $build = ($day * 1000) + $minutes
        $msiVersion = "$major.$minor.$build"

        $sourceDir = (Resolve-Path ./publish-msix).Path
        wix build packaging/wix/Leaf.wxs -arch x64 -d MsiVersion=$msiVersion -d SourceDir=$sourceDir -o Leaf.msi

    - name: Create Release Package
      shell: pwsh
      run: |
        # Create Leaf.zip from published files
        Compress-Archive -Path ./publish/* -DestinationPath ./Leaf.zip

        # Create release folder with install script and zip
        New-Item -ItemType Directory -Path ./release -Force
        Copy-Item ./Install-Leaf.ps1 ./release/
        Copy-Item ./Leaf.zip ./release/
        Copy-Item ./Leaf.msix ./release/
        if (Test-Path ./Leaf-Test.cer) { Copy-Item ./Leaf-Test.cer ./release/ }
        Copy-Item ./Leaf.msi ./release/

    - name: Upload Build Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Leaf-${{ steps.version.outputs.VERSION }}
        path: ./release/

    - name: Create GitHub Release
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ steps.version.outputs.VERSION }}
        name: Leaf v${{ steps.version.outputs.VERSION }}
        fail_on_unmatched_files: false
        body: |
          Automated release from main branch.

          ## Installation
          1. Download both files below
          2. Place them in the same folder
          3. Run `Install-Leaf.ps1` in PowerShell

          Or run: `powershell -ExecutionPolicy Bypass -File Install-Leaf.ps1`

          ## MSIX Installation (recommended)
          1. Download `Leaf.msix`
          2. If `Leaf-Test.cer` is included, install it to the Current User (or Local Machine) "Trusted People" store
          3. Double-click `Leaf.msix` to install

          For production signing, set `MSIX_PFX_BASE64` and `MSIX_PFX_PASSWORD` repo secrets to sign with your code-signing cert.

          ## MSI Installation (no tile background)
          1. Download `Leaf.msi`
          2. Double-click to install (admin required for per-machine install)
        files: |
          ./release/Install-Leaf.ps1
          ./release/Leaf.zip
          ./release/Leaf.msix
          ./release/Leaf-Test.cer
          ./release/Leaf.msi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
