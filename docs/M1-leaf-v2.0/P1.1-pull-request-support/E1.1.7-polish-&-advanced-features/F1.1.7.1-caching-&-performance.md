---
title: Caching & Performance
status: planned
owner: TBD
start_date: asap
duration: 0.5d
story_points: 3
depends_on: []
follows: []
---

# F1.1.7.1: Caching & Performance

**Description:**
Add thread-safe caching layer for PR list with 90-second TTL, path normalization, and cache invalidation after operations.

**Technical Approach:**

1. **Cache Structure:**
   ```csharp
   private static readonly TimeSpan CacheTtl = TimeSpan.FromSeconds(90);
   private readonly ConcurrentDictionary<string, (DateTime timestamp, List<PullRequestInfo> data)> _prListCache = new();
   private readonly SemaphoreSlim _cacheLock = new(1, 1);
   ```

2. **Path Normalization:**
   ```csharp
   private static string NormalizePath(string path)
   {
       return path
           .Replace('\\', '/')
           .TrimEnd('/')
           .ToLowerInvariant();  // Windows paths are case-insensitive
   }
   ```

3. **Cache Key:**
   ```csharp
   private static string BuildCacheKey(string repoPath, PullRequestStatus state, string? author, string? searchQuery)
   {
       var normalizedPath = NormalizePath(repoPath);
       var authorPart = string.IsNullOrWhiteSpace(author) ? "_" : author.ToLowerInvariant();
       var searchPart = string.IsNullOrWhiteSpace(searchQuery) ? "_" : searchQuery.ToLowerInvariant();
       return $"{normalizedPath}|{state}|{authorPart}|{searchPart}";
   }
   ```

4. **ListPullRequestsAsync with Cache:**
   ```csharp
   // Fast path: check cache without lock
   if (_prListCache.TryGetValue(cacheKey, out var cached) &&
       DateTime.UtcNow - cached.timestamp < CacheTtl)
       return cached.data;

   // Slow path: lock, double-check, fetch
   await _cacheLock.WaitAsync(cancellationToken);
   try {
       // Double-check after acquiring lock
       if (_prListCache.TryGetValue(cacheKey, out cached) && ...)
           return cached.data;

       var result = await FetchPullRequestsFromApiAsync(...);
       _prListCache[cacheKey] = (DateTime.UtcNow, result);
       return result;
   } finally { _cacheLock.Release(); }
   ```

5. **InvalidateCache:**
   ```csharp
   public void InvalidateCache(string repoPath)
   {
       var normalizedPath = NormalizePath(repoPath);
       var keysToRemove = _prListCache.Keys.Where(k => k.StartsWith($"{normalizedPath}|")).ToList();
       foreach (var key in keysToRemove)
           _prListCache.TryRemove(key, out _);
   }
   ```

6. **Call InvalidateCache after:** create, merge, close, update operations

7. **Lazy Loading Strategy:**
   - Load PR list immediately (limited fields)
   - Load files/commits/reviews only when PR is selected
   - Load comments only when comments section is expanded
   - Paginate large file lists (>100 files)
## Business Value

- **User Impact:** Fast PR list loading; reduced API calls; snappy UI response even with many PRs
- **Technical Value:** Thread-safe ConcurrentDictionary with 90s TTL; path normalization for consistent cache keys; double-checked locking pattern

## Inputs & Outputs

| Name | Type | Nullable | Description |
|:-----|:-----|:---------|:------------|
|  |  |  |  |

**Returns:** void - No return value

## Edge Cases & Boundary Conditions

| ID | Condition | Expected Behavior |
|:---|:----------|:------------------|
| EC-1 | Same repo, different path formats | Path normalization produces same cache key |
| EC-2 | Cache expires during request | Double-checked locking prevents duplicate fetches |
| EC-3 | User triggers refresh during cache validity | Force cache invalidation, fetch fresh data |
| EC-4 | Create/merge/close operation | Invalidate all caches for that repo path |

## Acceptance Criteria

### Functional
- [ ] ConcurrentDictionary used for thread-safe cache
- [ ] 90-second TTL implemented
- [ ] Path normalization handles backslash/forward slash, trailing slash, case
- [ ] Cache key includes: path, state, author, search query
- [ ] Fast path returns cached data without lock
- [ ] Slow path uses SemaphoreSlim for synchronization
- [ ] InvalidateCache called after create/merge/close/update

### Quality
- [ ] Double-checked locking pattern implemented correctly
- [ ] No compiler warnings

## Dependencies

| Type | ID/Name | Notes |
|:-----|:--------|:------|
| Depends On | None | |
| Blocks | None | |

## User Stories

### US-1: Fast PR List Loading

**User Story:**
> As a developer, I want PR list to load quickly so that I don't wait for API calls on every view.

**Acceptance Criteria:**
1. Given I viewed PR list recently, when I view again within 90s, then cached data displays instantly
2. Given I merge/close a PR, when I return to list, then cache is invalidated and fresh data loads
3. Given the same repo accessed via different path formats, then the same cached data is used

## Amendments

| Date | Category | Description | Rationale |
|:-----|:---------|:------------|:----------|

## Proposed Improvements

<!-- Document opportunities for refactoring, scope adjustments, or better engineering practices here. Do not implement yet; just log them. When a proposed improvement affects work above this item's level, document it in the appropriate ancestor. -->

| ID | Description | Resolution |
|:---|:------------|:-----------|
